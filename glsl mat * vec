绝大多数情况下，向量和矩阵的计算是逐分量进行的（component-wise）。当运算符作用于向量或矩阵时，该运算独立地作用于向量或矩阵的每个分量。
以下是一些示例：

vec3 v, u;
float f;
v = u + f;

等价于：

v.x = u.x + f;
v.y = u.y + f;
v.z = u.z + f;
1
2
3
4
5
6
7
8
9
再如：

vec3 v, u, w;
w = v + u;

等价于：

w.x = v.x + u.x;
w.y = v.y + u.y;
w.z = v.z + u.z;
1
2
3
4
5
6
7
8
对于整型和浮点型的向量和矩阵，绝大多数的计算都同上，但是对于向量乘以矩阵、矩阵乘以向量、矩阵乘以矩阵则是不同的计算规则。这三种计算使用线性代数的乘法规则，并且要求参与计算的运算数值有相匹配的尺寸或阶数。
例如：

vec3 v, u;
mat3 m;

向量乘以矩阵
u = v * m;

等价于：

u.x = dot(v, m[0]); // m[0] is the left column of m
u.y = dot(v, m[1]); // dot(a,b) is the inner (dot) product of a and b
u.z = dot(v, m[2]);
1
2
3
4
5
6
7
8
9
10
11
再如：

矩阵乘以向量
u = m * v;

等价于：

u.x = m[0].x * v.x + m[1].x * v.y + m[2].x * v.z;
u.y = m[0].y * v.x + m[1].y * v.y + m[2].y * v.z;
u.z = m[0].z * v.x + m[1].z * v.y + m[2].z * v.z;
1
2
3
4
5
6
7
8
再如：

矩阵乘以矩阵
mat m, n, r;
r = m * n;

等价于：

r[0].x = m[0].x * n[0].x + m[1].x * n[0].y + m[2].x * n[0].z;
r[1].x = m[0].x * n[1].x + m[1].x * n[1].y + m[2].x * n[1].z;
r[2].x = m[0].x * n[2].x + m[1].x * n[2].y + m[2].x * n[2].z;
r[0].y = m[0].y * n[0].x + m[1].y * n[0].y + m[2].y * n[0].z;
r[1].y = m[0].y * n[1].x + m[1].y * n[1].y + m[2].y * n[1].z;
r[2].y = m[0].y * n[2].x + m[1].y * n[2].y + m[2].y * n[2].z;
r[0].z = m[0].z * n[0].x + m[1].z * n[0].y + m[2].z * n[0].z;
r[1].z = m[0].z * n[1].x + m[1].z * n[1].y + m[2].z * n[1].z;
r[2].z = m[0].z * n[2].x + m[1].z * n[2].y + m[2].z * n[2].z;

glsl的矩阵mat是按照列存储的:mat2 m = mat2(1.0, 2.0, 3.0, 4.0)等同与:
  [1.0 3.0
  2.0,4.0]
  Matrix components are read out of arguments in column major order and written in column major order.

  vec4 color = vec4(1.0,1.0,0.0,0.0)
   mat2 xycolor = mat2(color);则mat2[0] = [1.0,1.0]
  
